import { Err, Ok, Result, match } from "oxide.ts";

const URLS = {
  AUTH: {
    AUTHORIZATION_URL: "https://accounts.spotify.com/authorize",
    ACCESS_TOKEN: "https://accounts.spotify.com/api/token",
  },
};

const SpotifyErrorType = {
  NETWORK_ERROR: "NETWORK_ERROR",
  REQUEST_ERROR: "REQUEST_ERROR",
  RESPONSE_ERROR: "RESPONSE_ERROR",
} as const;
type SpotifyErrorType =
  (typeof SpotifyErrorType)[keyof typeof SpotifyErrorType];

type SpotifyErrorContextType = {
  NETWORK_ERROR: { request: Request };
  REQUEST_ERROR: { request: Request; response: Response };
  RESPONSE_ERROR: { request: Request; response: Response };
};

type SpotifyErrorContext<Type extends SpotifyErrorType> =
  SpotifyErrorContextType[Type];

export class SpotifyAPIError<Type extends SpotifyErrorType> extends Error {
  type: Type;
  context: SpotifyErrorContext<SpotifyErrorType>;
  cause?: unknown;

  constructor(
    type: Type,
    message: string,
    context: SpotifyErrorContext<Type>,
    cause?: unknown
  ) {
    super(message);
    this.type = type;
    this.cause = cause;
    this.context = context;
  }
}

type QueryParams = [string, string];
type AuthorizationRequest =
  | { type: "code"; authorizationCode: string }
  | { type: "token"; refreshToken: string };

export class SpotifyAuth {
  clientID: string;
  clientSecret: string;
  redirectURI: string;

  constructor(clientID: string, clientSecret: string, redirectURI: string) {
    this.clientID = clientID;
    this.clientSecret = clientSecret;
    this.redirectURI = redirectURI;
  }

  createAuthorizationURL(scopes: string[], state: string): string {
    const url = new URL(URLS.AUTH.AUTHORIZATION_URL);
    const params: QueryParams[] = [
      ["response_type", "code"],
      ["client_id", this.clientID],
      ["scope", scopes.join(" ")],
      ["state", state],
    ];

    for (const [name, value] of params) {
      url.searchParams.append(name, value);
    }

    return url.toString();
  }

  /**
   * Access token can be requested in two ways.
   * 1. The initial access token is generated by using
   * the authorization code provided by the redirect flow .
   * 2. Subsequent access tokens can be generated using the
   * refresh token provided in the response of the first flow.
   *
   * The only difference between the two flows is the form data,
   * which is handled using the "switch" case.
   * @param authorization
   */
  async requestAccessToken(authorization: AuthorizationRequest) {
    const url = new URL(URLS.AUTH.ACCESS_TOKEN);
    const authorizationHeader = btoa(`${this.clientID}:${this.clientSecret}`);

    const params: QueryParams[] = [];
    switch (authorization.type) {
      case "code":
        params.push(
          ["grant_type", "authorization_code"],
          ["code", authorization.authorizationCode],
          ["redirect_uri", this.redirectURI]
        );
        break;
      case "token":
        params.push(
          ["grant_type", "refresh_token"],
          ["refresh_token", authorization.refreshToken]
        );
        break;
    }

    for (const [name, value] of params) {
      url.searchParams.append(name, value);
    }

    const request = new Request(url.toString(), {
      method: "POST",
      headers: {
        Authorization: `Basic ${authorizationHeader}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
    });

    let response: Response;
    try {
      response = await fetch(request);
    } catch (error) {
      return new SpotifyAPIError(
        SpotifyErrorType.NETWORK_ERROR,
        "",
        { request },
        error
      );
    }

    if (!response.ok) {
      return new SpotifyAPIError(SpotifyErrorType.REQUEST_ERROR, "", {
        request,
        response,
      });
    }

    try {
      const responseJson = parse;

    } catch (error) {

    }
  }
}
